<!DOCTYPE html>
<html lang='en' ><meta charset="utf-8">
<meta name="viewport" content="width=device-width">


<title>Analyzing Ceph Network Module | Better Tomorrow with Computer Science</title>
<link rel="stylesheet" href="/css/eureka.min.css">
<script defer src="/js/eureka.min.js"></script>

<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="preload"
  href="https://fonts.googleapis.com/css2?family=Lora:wght@400;600;700&family=Noto+Serif+SC:wght@400;600;700&display=swap"
  as="style" onload="this.onload=null;this.rel='stylesheet'">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/styles/solarized-light.min.css"
   media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jpswalsh/academicons@1.8.6/css/academicons.min.css"
   crossorigin>
<script defer src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@10.1.0/build/highlight.min.js"
   crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/js/all.min.js"
   integrity="sha256-uNYoXefWRqv&#43;PsIF/OflNmwtKM4lStn9yrz2gVl6ymo="  crossorigin></script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css"
   integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3&#43;Aro6EYUG4&#43;cU&#43;KJWu/X"  media="print"
  onload="this.media='all';this.onload=null" crossorigin>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js" 
  integrity="sha384-g7c&#43;Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI&#43;sEnkvrMWph2EDg4"  crossorigin></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js"
   integrity="sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC&#43;Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa"  crossorigin></script>
<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: "$$", right: "$$", display: true },
        { left: "$", right: "$", display: false },
        { left: "\\(", right: "\\)", display: false },
        { left: "\\[", right: "\\]", display: true }
      ],
    });
  });
</script>
<link rel="preconnect" href="https://www.google-analytics.com" crossorigin>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-158110335-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());
  gtag('config', 'UA-158110335-1');
</script>


<link rel="icon" type="image/png" sizes="32x32" href="/umich_hu6c99b92144fcbc4e30752e6c6d9a0d50_18545_32x32_fill_box_center_3.png">
<link rel="apple-touch-icon" sizes="180x180" href="/umich_hu6c99b92144fcbc4e30752e6c6d9a0d50_18545_180x180_fill_box_center_3.png">

<meta name="description"
  content="Eureka is a elegant and powerful theme for Hugo.">
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [{
      "@type": "ListItem",
      "position": 1 ,
      "name":"Posts",
      "item":"/posts/"},{
      "@type": "ListItem",
      "position": 2 ,
      "name":"Analyzing Ceph Network Module",
      "item":"/2020-12-23/analyzing-ceph-network-module/"}]
}
</script>



<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "Article",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "/2020-12-23/analyzing-ceph-network-module/"
    },
    "headline": "Analyzing Ceph Network Module | Better Tomorrow with Computer Science","datePublished": "2020-12-23T11:38:00+09:00",
    "dateModified": "2020-12-23T11:38:00+09:00",
    "wordCount":  3263 ,
    "publisher": {
        "@type": "Person",
        "name": "Insu Jang",
        "logo": {
            "@type": "ImageObject",
            "url": "/umich.png"
        }
        },
    "description": "Eureka is a elegant and powerful theme for Hugo."
}
</script><meta property="og:title" content="Analyzing Ceph Network Module | Better Tomorrow with Computer Science" />
<meta property="og:type" content="article" />


<meta property="og:image" content="/umich.png">


<meta property="og:url" content="/2020-12-23/analyzing-ceph-network-module/" />




<meta property="og:description" content="" />




<meta property="og:locale" content="en" />




<meta property="og:site_name" content="Better Tomorrow with Computer Science" />






<meta property="article:published_time" content="2020-12-23T11:38:00&#43;09:00" />


<meta property="article:modified_time" content="2020-12-23T11:38:00&#43;09:00" />



<meta property="article:section" content="posts" />


<meta property="article:tag" content="study" />

<meta property="article:tag" content="ceph" />





<meta property="og:see_also" content="/2020-11-07/accelerating-ceph-rpm-packaging-using-multithreaded-compression/" />

<meta property="og:see_also" content="/2020-11-03/deploying-a-ceph-development-environment-cluster/" />

<meta property="og:see_also" content="/2020-08-30/introduction-to-ceph/" />

<meta property="og:see_also" content="/2020-11-09/building-container-image-inside-container-using-buildah/" />

<meta property="og:see_also" content="/2020-08-27/introduction-to-flatpak/" />

<meta property="og:see_also" content="/2020-08-24/dynamic-kubelet-configuration/" />



<body class="flex flex-col min-h-screen">
  <header class="fixed flex items-center w-full min-h-16 pl-scrollbar z-50 bg-secondary-bg shadow-sm">
    <div class="w-full max-w-screen-xl mx-auto"><script>
    let storageColorScheme = localStorage.getItem("lightDarkMode")
    if ((storageColorScheme == 'Auto' && window.matchMedia("(prefers-color-scheme: dark)").matches) || storageColorScheme == "Dark") {
        document.getElementsByTagName('html')[0].classList.add('dark')
    }
</script>
<nav class="flex items-center justify-between flex-wrap p-4">
    <a href="/" class="mr-6 text-primary-text font-bold">Better Tomorrow with Computer Science</a>
    <button id="navbar-btn" class="md:hidden flex items-center px-3 py-2" aria-label="Open Navbar">
        <i class="fas fa-bars"></i>
    </button>

    <div id="target"
        class="hidden block md:flex md:flex-grow md:justify-between md:items-center w-full md:w-auto text-primary-text z-20">
        <div class="text-sm md:flex-grow pb-4 md:pb-0 border-b md:border-b-0">
            <a href="/#about"
                class="block mt-4 md:inline-block md:mt-0  hover:text-eureka mr-4">About</a>
            <a href="/posts/"
                class="block mt-4 md:inline-block md:mt-0  hover:text-eureka mr-4">Posts</a>
        </div>

        <div class="flex">
            <div class="relative pt-4 md:pt-0">
                <div class="cursor-pointer hover:text-eureka" id="lightDarkMode">
                    <i class="fas fa-sun"></i>
                </div>
                <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-30" id="is-open">
                </div>
                <div class="absolute flex flex-col left-0 md:left-auto right-auto md:right-0 hidden bg-secondary-bg w-48 rounded py-2 border border-tertiary-bg cursor-pointer z-40"
                    id='lightDarkOptions'>
                    <span class="px-4 py-1 hover:text-eureka">Light</span>
                    <span class="px-4 py-1 hover:text-eureka">Dark</span>
                    <span class="px-4 py-1 hover:text-eureka">Auto</span>
                </div>
            </div>
        </div>
    </div>

    <div class="fixed hidden inset-0 opacity-0 h-full w-full cursor-default z-0" id="is-open-mobile">
    </div>

</nav>
<script>
    let element = document.getElementById('lightDarkMode')
    if (storageColorScheme == 'Auto') {
        element.firstElementChild.classList.remove('fa-sun')
        element.firstElementChild.setAttribute("data-icon", 'adjust')
        element.firstElementChild.classList.add('fa-adjust')
        document.addEventListener('DOMContentLoaded', () => {
            switchMode('Auto')
        })
    } else if (storageColorScheme == "Dark") {
        element.firstElementChild.classList.remove('fa-sun')
        element.firstElementChild.setAttribute("data-icon", 'moon')
        element.firstElementChild.classList.add('fa-moon')
    }
    
    document.addEventListener('DOMContentLoaded', () => {
        getcolorscheme();
        switchBurger();
    });
</script></div>
  </header>
  <main class="flex-grow pt-16">
      <div class="w-full max-w-screen-xl lg:px-4 xl:px-8 mx-auto">


<div class="lg:pt-12"></div>
<div
    class="col-span-2 lg:col-start-2 lg:col-span-6 bg-secondary-bg rounded px-6 py-8">
    <h1 class="font-bold text-3xl text-primary-text">Analyzing Ceph Network Module</h1>
    <div class="mr-6 my-2">
    <span>Dec 23, 2020</span>
</div>




    
    
    

    <div class="content">
        <p>This post explains how Ceph daemons and clients communicate with each other, with Ceph network architecture.</p>
<p>Ceph offical document provides a very high-level diagram that depicts the Ceph architecture:</p>
<figure><img src="/assets/images/201205/ceph-stack.png"
         alt="image"/><figcaption>
            <p>High level Ceph architecture. <a href="https://docs.ceph.com/en/latest/architecture/">[src]</a></p>
        </figcaption>
</figure>

<p>However, I could not find out detailed documents explaining how clients with librados actually communicate with daemons, except a few blog post <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup> <sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup> <sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup> <sup id="fnref:4"><a href="#fn:4" class="footnote-ref" role="doc-noteref">4</a></sup> <sup id="fnref:5"><a href="#fn:5" class="footnote-ref" role="doc-noteref">5</a></sup> <sup id="fnref:6"><a href="#fn:6" class="footnote-ref" role="doc-noteref">6</a></sup> <sup id="fnref:7"><a href="#fn:7" class="footnote-ref" role="doc-noteref">7</a></sup>.
Even after reading those, I was not clear how they work.
Therefore, I visualize the execution flow for network communication of Ceph and summarizes the concept here.</p>
<h2 id="1-ceph-network-architecture-overview">1. Ceph Network Architecture Overview</h2>
<figure><img src="/assets/images/201223/ceph-network-overview.png"
         alt="image"/><figcaption>
            <p>Ceph network class diagram.</p>
        </figcaption>
</figure>

<blockquote>
<p>Explanations of three types of arrows used in the class diagram:</p>
<ol>
<li>solid line with white block arrow: indicates class inheritance.</li>
<li>solid line with line arrow: indicates ownership.</li>
<li>dot line with line arrow: indicates reference.</li>
</ol>
</blockquote>
<p>Roughly those classes can be grouped into four categories:</p>
<ul>
<li><code>Messenger</code>, <code>Connecttion</code>, and <code>Processor</code></li>
<li><code>Dispatcher</code>, <code>DispatchQueue</code>, and <code>DispatchThread</code> (<code>DispatchThread</code> is not illustrated in the class diagram)</li>
<li><code>NetworkStack</code> and <code>Worker</code></li>
<li><code>EventCenter</code> and <code>EventDriver</code></li>
</ul>
<figure><img src="/assets/images/201223/ceph-network-osd-init.png"
         alt="image"/><figcaption>
            <p>Function execution flow diagram when OSD accepts a connection and communicate.</p>
        </figcaption>
</figure>

<figure><img src="/assets/images/201223/ceph-network-radosclient-connect.png"
         alt="image"/><figcaption>
            <p>Function execution flow diagram when a client connects to a peer server and communicate using <code>librados</code>.</p>
        </figcaption>
</figure>

<p>The function execution flows illustrated above is a rough illustration of function calls happening in connection establishment.
First one is by OSD, and the other one is by librados.
It would be helpful to see these flow diagram with the code below.</p>
<h2 id="2-messenger-connection-and-processor">2. <code>Messenger</code>, <code>Connection</code>, and <code>Processor</code></h2>
<h3 id="messenger"><code>Messenger</code></h3>
<p>Central to the architecture is <code>Messenger</code> class. Currently only <code>AsyncMessenger</code> is provided and used.
Messenger manages all the other class instances: connections, processors, a dispatch queue, a network stack (which manages workers, which owns an EventCenter, which owns an EventDriver), and dispatchers.</p>
<p>Every time it connected to a peer, it creates an <code>AsyncConnection</code> class and returns it. To create a connection, <code>AsyncMessenger</code> provides the following two functions:</p>
<ul>
<li><code>connect_to()</code>: connect to peers with the given <code>entity_addrvec_t&amp; addrs</code> address information.</li>
<li><code>bindv()</code>: bind a server socket so that it can accept a connection establishment request.</li>
</ul>
<p>Usage example (<code>connect_to()</code> by client):</p>
<pre><code class="language-cpp">librados::RadosClient::connect()
-&gt; MonClient::authenticate()
-&gt; MonClient::_reopen_session()
-&gt; MonClient::_add_conn()
-&gt; Messenger::connect_to_mon()
-&gt; AsyncMessenger::connect_to()
</code></pre>
<p><code>src/librados/RadosClient.cc</code></p>
<pre><code class="language-cpp">int librados::RadosClient::connect() {
  ...
  monclient.build_initial_monmap();
  messenger = Messenger::create_client_messenger(cct, &quot;radosclient&quot;);
  ...
  monclient.set_messenger(messenger);
  messenger-&gt;add_dispatcher_tail(this);
  messenger-&gt;start();
  ...
  monclient.init();
  monclient.authenticate(conf-&gt;client_mount_timeout);
  ...
}
</code></pre>
<p><code>src/mon/MonClient.cc</code></p>
<pre><code class="language-cpp">int MonClient::authenticate(double timeout) {
  ...
  if (!_opened())
    _reopen_session();

  ...
  auth_cond.wait(lock);
  ...
}

void MonClient::_reopen_session(int rank) {
  active_con.reset();
  pending_cons.clear();

  if (rank &gt;= 0) _add_conn(rank, global_id);
  else _add_conns(global_id);
  ...

  for (auto&amp; c : pending_cons) {
    c.second.start(monmap.get_epoch(), entity_name);
  }
  ...
}

int MonClient::_add_conn(unsigned rank, uint64_t global_id) {
  auto peer = monmap.get_addrs(rank);
  // type: ConnectionRef == ceph::ref_t&lt;Connection&gt;
  //                     == boost::intrusive_ptr&lt;Connection&gt;
  auto conn = messenger-&gt;connect_to_mon(peer);
  ...
}
</code></pre>
<p><code>src/msg/Messenger.h</code></p>
<pre><code class="language-cpp">// AsyncMessenger inherits this class
class Messenger {
  ...
  virtual ConnectionRef connect_to(
    int type, const entity_addrvec_t&amp; dest,
    bool anon=false, bool not_local_dest=false) = 0;
  ConnectionRef connect_to_mon(const entity_addrvec_t&amp; dest,
        bool anon=false, bool not_local_dest=false) {
	  return connect_to(CEPH_ENTITY_TYPE_MON, dest, anon, not_local_dest);
  }
  ConnectionRef connect_to_mds(const entity_addrvec_t&amp; dest,
        bool anon=false, bool not_local_dest=false) {
	  return connect_to(CEPH_ENTITY_TYPE_MDS, dest, anon, not_local_dest);
  }
  ConnectionRef connect_to_osd(const entity_addrvec_t&amp; dest,
        bool anon=false, bool not_local_dest=false) {
	  return connect_to(CEPH_ENTITY_TYPE_OSD, dest, anon, not_local_dest);
  }
  ConnectionRef connect_to_mgr(const entity_addrvec_t&amp; dest,
        bool anon=false, bool not_local_dest=false) {
	  return connect_to(CEPH_ENTITY_TYPE_MGR, dest, anon, not_local_dest);
  }
  ...
}
</code></pre>
<p>Usage example (<code>bindv()</code> by osd server):</p>
<pre><code class="language-cpp">main() (ceph-osd.cc)
-&gt; AsyncMessenger::bindv()
</code></pre>
<p><code>src/ceph-osd.cc</code></p>
<pre><code class="language-cpp">int main(int argc, const char **argv) {
  ...
  Messenger *ms_public = Messenger::create(g_ceph_context, public_msg_type,
					   entity_name_t::OSD(whoami), &quot;client&quot;, nonce);
  Messenger *ms_cluster = Messenger::create(g_ceph_context, cluster_msg_type,
					    entity_name_t::OSD(whoami), &quot;cluster&quot;, nonce);
  Messenger *ms_hb_back_client = Messenger::create(g_ceph_context, cluster_msg_type,
					     entity_name_t::OSD(whoami), &quot;hb_back_client&quot;, nonce);
  Messenger *ms_hb_front_client = Messenger::create(g_ceph_context, public_msg_type,
					     entity_name_t::OSD(whoami), &quot;hb_front_client&quot;, nonce);
  Messenger *ms_hb_back_server = Messenger::create(g_ceph_context, cluster_msg_type,
						   entity_name_t::OSD(whoami), &quot;hb_back_server&quot;, nonce);
  Messenger *ms_hb_front_server = Messenger::create(g_ceph_context, public_msg_type,
						    entity_name_t::OSD(whoami), &quot;hb_front_server&quot;, nonce);
  Messenger *ms_objecter = Messenger::create(g_ceph_context, public_msg_type,
					     entity_name_t::OSD(whoami), &quot;ms_objecter&quot;, nonce);
  ...

  ms_public-&gt;bindv(public_addrs);
  ms_cluster-&gt;bindv(cluster_addrs);
  ms_hb_front_server-&gt;bindv(hb_front_addrs);
  ms_hb_front_client-&gt;client_bind(hb_front_addrs.front());
  ms_hb_back_server-&gt;bindv(hb_back_addrs);
  ms_hb_back_client-&gt;client_bind(hb_back_addrs.front());
  ...

  ms_public-&gt;start();
  ms_hb_front_client-&gt;start();
  ms_hb_back_client-&gt;start();
  ms_hb_front_server-&gt;start();
  ms_hb_back_server-&gt;start();
  ms_cluster-&gt;start();
  ...
}
</code></pre>
<h3 id="connection"><code>Connection</code></h3>
<blockquote>
<p>AsyncConnection maintains a logic session between two endpoints.
In other words, a pair of addresses can find the only AsyncConnection.
AsyncConnection will handle with network fault or read/write transactions.
If one file descriptor broken, AsyncConnection will maintain the message queue and sequence, try to reconnect peer endpoint.</p>
</blockquote>
<p>When a client connects to a peer server or a server accepts a connection request from a client peer, an <code>AsyncConnection</code> class instance is created.
It is managed by <code>AsyncMessenger</code>, and any read or write is at first handled by the <code>AsyncConnection</code>.</p>
<pre><code class="language-cpp">AsyncMessenger::connect_to()
-&gt; AsyncMessenger::create_connect()
-&gt; ceph::make_ref&lt;AsyncConnection&gt;()
-&gt; new ceph::ref_t&lt;AsyncConnection&gt;({new AsyncConnection(...), false})
    == boost::intrusive_ptr&lt;AsyncConnection&gt;({new AsyncConnection(...), false})
</code></pre>
<p><code>src/msg/async/AsyncMessenger.cc</code></p>
<pre><code class="language-cpp">ConnectionRef AsyncMessenger::connect_to(int type,
					const entity_addrvec_t&amp; addrs,
					bool anon, bool not_local_dest) {
  ...
  AsyncConnectionRef conn = _lookup_conn(av);
  if (!conn) {
    conn = create_connect(av, type, false);
  }
  return conn;
}

AsyncConnectionRef AsyncMessenger::create_connect(
          const entity_addrvec_t&amp; addrs, int type, bool anon) {
  ...
  Worker *w = stack-&gt;get_worker();
  auto conn = ceph::make_ref&lt;AsyncConnection&gt;(cct, this, &amp;dispatch_queue, w,
						target.is_msgr2(), false);
  conn-&gt;connect(addrs, type, target);
  return conn;
}
</code></pre>
<p>Server processes create an <code>AsyncConnection</code> when it receives a connection establishment request, which means we need to discuss more about asynchronous mechanism how <code>accept()</code> callback is called for full understanding.
Here, however, let&rsquo;s just show a simple class instantiation only.</p>
<pre><code class="language-cpp">Processor::C_processor_accept::do_request()
-&gt; Processor::accept() (-&gt; PosixServerSocketImpl::accept() -&gt; accept_cloexec())
-&gt; AsyncMessenger::add_accept()
-&gt; ceph::make_ref&lt;AsyncConnection&gt;()
</code></pre>
<p><code>src/msg/async/AsyncMessenger.cc</code></p>
<pre><code class="language-cpp">class Processor::C_processor_accept : public EventCallback {
  Processor *pro;
  explicit C_processor_accept(Processor *p): pro(p) {}
  void do_request(uint64_t id) override {
    pro-&gt;accept();
  }
};

void Processor::accept() {
  ...
  for (auto&amp; listen_socket : listen_sockets) {
    ...
    ConnectedSocket cli_socket;
    listen_socket.accept(&amp;cli_socket, opts, &amp;addr, w);
    msgr-&gt;add_accept(
            w, std::move(cli_socket),
            msgr-&gt;get_myaddrs().v[listen_socket.get_addr_slot()],
            addr);
    continue;
  }
}

// listen_socket.accept() in src/msg/async/PosixStack.cc
int PosixServerSocketImpl::accept(ConnectedSocket *sock, const SocketOptions &amp;opt, entity_addr_t *out, Worker *w) {
  int sd = accept_cloexec(_fd, (sockaddr*)&amp;ss, &amp;slen);
  ...

  std::unique_ptr&lt;PosixConnectedSocketImpl&gt; csi(new PosixConnectedSocketImpl(handler, *out, sd, true));
  *sock = ConnectedSocket(std::move(csi));
  return 0;
}

// msgr-&gt;add_accept() in src/msg/async/AsyncMessenger.cc
void AsyncMessenger::add_accept(Worker *w, ConnectedSocket cli_socket,
				const entity_addr_t &amp;listen_addr,
				const entity_addr_t &amp;peer_addr) {
  auto conn = ceph::make_ref&lt;AsyncConnection&gt;(cct, this, &amp;dispatch_queue, w,
						listen_addr.is_msgr2(), false);
  conn-&gt;accept(std::move(cli_socket), listen_addr, peer_addr);
  accepting_conns.insert(conn);
}
</code></pre>
<h3 id="processor"><code>Processor</code></h3>
<p>Currently, <code>Processor</code> seems to be used only by servers, and not used by clients.
It is responsible for:</p>
<ul>
<li><code>bind()</code>: bind and listen to a socket so that the socket can receive a request.</li>
<li><code>accept()</code>: handle accept callback event.</li>
</ul>
<p>When binding a server socket:</p>
<pre><code class="language-cpp">AsyncMessenger::bindv()
-&gt; Processor::bind()
-&gt; PosixWorker::listen()
-&gt; ::bind() and ::listen() and new PosixServerSocketImpl()
</code></pre>
<p><code>src/msg/async/AsyncMessenger.cc</code></p>
<pre><code class="language-cpp">int AsyncMessenger::bindv(const entity_addrvec_t &amp;bind_addrs) {
  ...
  for (auto &amp;&amp;p : processors) {
    p-&gt;bind(bind_addrs, avoid_ports, &amp;bound_addrs);
  }
  ...
}

int Processor::bind(const entity_addrvec_t &amp;bind_addrs,
		    const std::set&lt;int&gt;&amp; avoid_ports,
		    entity_addrvec_t* bound_addrs) {
  for (unsigned k = 0; k &lt; bind_addrs.v.size(); ++k) {
    worker-&gt;center.submit_to(
      worker-&gt;center.get_id(),
      [this, k, &amp;listen_addr, &amp;opts, &amp;r]() {
        r = worker-&gt;listen(listen_addr, k, opts, &amp;listen_socket[k]);
      }, false
    );
  }
}
</code></pre>
<p>Now the lambda function that contains <code>worker-&gt;listen()</code> call is submitted to the <code>EventCenter</code> and will be executed asynchronously later, but let&rsquo;s see just how it looks first. Will be discussed the asynchronous mechanism later.</p>
<p><code>src/msg/async/PosixStack.cc</code></p>
<pre><code class="language-cpp">int PosixWorker::listen(entity_addr_t &amp;sa, unsigned addr_slot,
			const SocketOptions &amp;opt, ServerSocket *sock) {
  int listen_sd = net.create_socket(sa.get_family(), true);
  ::bind(listen_sd, sa.get_sockaddr(), sa.get_sockaddr_len());
  ::listen(listen_sd, cct-&gt;_conf-&gt;ms_tcp_listen_backlog);

  *sock = ServerSocket(
      std::unique_ptr&lt;PosixServerSocketImpl&gt;(
          new PosixServerSocketImpl(net, listen_sd, sa, addr_slot)));
  return 0;
}
</code></pre>
<p>And the created socket file descriptor has an event, <code>EventCenter</code> calls <code>Processor::C_processor_accept::do_request()</code> as a callback (Will discuss it later too).
This callback function actually accepts a request and create a <code>ConnectedSocket</code> and an <code>AsyncConnection</code>.</p>
<pre><code class="language-cpp">Processor::C_processor_accept::do_request()
-&gt; Processor::accept() (-&gt; PosixServerSocketImpl::accept() -&gt; accept_cloexec(), and new PosixConnectedSocketImpl())
-&gt; AsyncMessenger::add_accept()
-&gt; ceph::make_ref&lt;AsyncConnection&gt;()
</code></pre>
<p>This process is already handled in <a href="#connection"><code>Messenger</code> section</a>, so I would skip duplicated explanation here.</p>
<h2 id="3-dispatcher-dispatchqueue-and-dispatchthread">3. <code>Dispatcher</code>, <code>DispatchQueue</code>, and <code>DispatchThread</code></h2>
<p><code>Dispatcher</code> is a virtual class that declares several callback handlers, and several classes inherit <code>Dispatcher</code> class and override the callback handlers to implement their functionalities.
For example, <code>OSD (src/osd/OSD.h)</code> inherits <code>Dispatcher</code> and implements <code>ms_dispatch(Message *m)</code> to handle messages from clients.
<code>librados::RadosClient (src/librados/RadosClient.h)</code> also inherits <code>Dispatcher</code> to wait replies from server processes.</p>
<p><code>src/osd/OSD.h</code></p>
<pre><code class="language-cpp">class OSD : public Dispatcher, public md_config_obs_t {

private:
  bool ms_can_fast_dispatch_any() const override { return true; }
  bool ms_can_fast_dispatch(const Message *m) const override {
    ...
  }

  void ms_fast_dispatch(Message *m) override;
  bool ms_dispatch(Message *m) override;
  void ms_handle_connect(Connection *con) override;
  void ms_handle_fast_connect(Connection *con) override;
  void ms_handle_fast_accept(Connection *con) override;
  int ms_handle_authentication(Connection *con) override;
  bool ms_handle_reset(Connection *con) override;
  void ms_handle_remote_reset(Connection *con) override {}
  bool ms_handle_refused(Connection *con) override;
  ...
}
</code></pre>
<p><code>src/librados/RadosClient.h</code></p>
<pre><code class="language-cpp">class librados::RadosClient : public Dispatcher, public md_config_obs_t {
private:
  bool _dispatch(Message *m);
  bool ms_dispatch(Message *m) override;

  void ms_handle_connect(Connection *con) override;
  bool ms_handle_reset(Connection *con) override;
  void ms_handle_remote_reset(Connection *con) override;
  bool ms_handle_refused(Connection *con) override;
  ...
}
</code></pre>
<p>The <code>ms_handle_*()</code> functions will be called by <code>DispatchThread</code>, when a queue item is enqueued into the <code>DispatchQueue</code>.
<code>DispatchThread</code> and an actual thread is created when you call <code>Messenger::add_dispatcher_head()</code> or <code>Messenger::add_dispatcher_tail()</code> for the first time: these functions are required to be called by dispatchers so that <code>Messenger</code> can call registered dispatcher functions.</p>
<p>For OSD daemon, an <code>OSD</code> class instance (which inherited <code>Dispatcher</code>) adds itself to an <code>AsyncMessenger</code> class instance by calling <code>add_dispatcher_tail(this)</code> during OSD initialization:</p>
<pre><code class="language-cpp">main() (ceph-osd.cc)
-&gt; OSD::init()
-&gt; AsyncMessenger::add_dispatcher_tail()
-&gt; AsyncMessenger::ready()
-&gt; DispatchQueue::start()
-&gt; Thread::create()
-&gt; Thread::try_create()
-&gt; pthread_create()
-&gt; (thread) Thread::entry_wrapper()
-&gt; (thread) DispatchThread::entry()
-&gt; (thread) DispatchQueue::entry()
</code></pre>
<p><code>src/msg/Messenger.h</code></p>
<pre><code class="language-cpp">void Messenger::add_dispatcher_tail(Dispatcher *d) {
  bool first = dispatchers.empty();
  dispatchers.push_back(d);
  if (d-&gt;ms_can_fast_dispatch_any())
    fast_dispatchers.push_back(d);
  if (first)
    ready();
}
</code></pre>
<p><code>src/msg/async/AsyncMessenger.cc</code></p>
<pre><code class="language-cpp">void AsyncMessenger::ready() {
  stack-&gt;ready();
  ...
  
  dispatch_queue.start(); // Here, dispatch queue is started.
}
</code></pre>
<p><code>src/msg/DispatchQueue.cc</code></p>
<pre><code class="language-cpp">void DisaptchQueue::start() {
  ...
  dispatch_thread.create(&quot;ms_dispatch&quot;);
}
</code></pre>
<p><code>src/common/Thread.cc</code></p>
<pre><code class="language-cpp">// DispatchThread inherits Thread.
void Thread::create(const char *name, size_t stacksize) {
  ...
  try_create(stacksize);
}

int Thread::try_create(size_t stacksize) {
  ...
  pthread_create(&amp;thread_id, thread_attr, _entry_func, (void*)this);
  ...
}

void *Thread::_entry_func(void *arg) {
  void *r = ((Thread*)arg)-&gt;entry_wrapper();
  return r;
}

void *Thread::entry_wrapper() {
  ...
  return entry();
}

// Note that entry() of DispatchThread is overridden:
// in src/msg/DispatchQueue.h
class DispatchThread : public Thread {
  DispatchQueue *dq;

public:
  explicit DispatchThread(DispatchQueue *dq) : dq(dq) {}
  void *entry() override {
    dq-&gt;entry();
    return 0;
  }
} dispatch_thread;
</code></pre>
<p>Note that <code>dq-&gt;entry()</code> calls <code>DispatchQueue::entry()</code>, which runs in an additional dispatch thread, and it handles enqueued items by calling <code>Messenger::ms_deliver_handle_*()</code> functions that actually calls <code>Dispatcher</code>s' callback functions:</p>
<p><code>src/msg/DispatchQueue.cc</code></p>
<pre><code class="language-cpp">void DispatchQueue::entry() {
  while (true) {
    while (!mqueue.empty()) {
      QueueItem qitem = mqueue.dequeue();
      ...
      if (qitem.is_code()) {
        switch (qitem.get_code()) {
          case D_BAD_REMOTE_RESET:
            msgr-&gt;ms_deliver_handle_remote_reset(qitem.get_connection());
            break;
          case D_CONNECT:
            msgr-&gt;ms_deliver_handle_connect(qitem.get_connection());
            break;
          case D_ACCEPT:
            msgr-&gt;ms_deliver_handle_accept(qitem.get_connection());
            break;
          case D_BAD_RESET:
            msgr-&gt;ms_deliver_handle_reset(qitem.get_connection());
            break;
          case D_CONN_REFUSED:
            msgr-&gt;ms_deliver_handle_refused(qitem.get_connection());
            break;
          default:
            ceph_abort();
        }
      } else {
        const ref_t&lt;Message&gt;&amp; m = qitem.get_message();
        uint64_t msize = pre_dispatch(m);
        msgr-&gt;ms_deliver_dispatch(m);
        post_dispatch(m, msize);
      }
    }

    l.lock();
  }

  if (stop)
    break;

  // wait for something to be put on queue
  cond.wait(l);
}
</code></pre>
<p>For instance, if a message is delivered, <code>msgr-&gt;ms_deliver_dispatch(m)</code> is called:</p>
<p><code>src/msg/Messenger.h</code></p>
<pre><code class="language-cpp">void Messenger::ms_deliver_dispatch(const ceph::ref_t&lt;Message&gt; &amp;m) {
  m-&gt;set_dispatch_stamp(ceph_clock_now());
  for (const auto &amp;dispatcher : dispatchers) {
    dispatcher-&gt;ms_dispatch2(m);
  }
}

// Note that ms_dispatch2 is a tricky implementation that actually calls ms_dispatch.
// src/msg/Dispatcher.h
/* ms_dispatch2 because otherwise the child must define both */
virtual bool Dispatcher::ms_dispatch2(const MessageRef &amp;m) {
  MessageRef mr(m);
  ms_dispatch(mr.get());
}
</code></pre>
<p>Here, we know that <code>Dispatcher</code> class instances added themselves into the <code>Messenger</code>, so they are stored in <code>dispatchers</code> variable: the <code>Messenger</code> iterates those added dispatchers and call the implemented <code>ms_dispatch()</code> function.</p>
<h2 id="4-networkstack-and-worker">4. <code>NetworkStack</code> and <code>Worker</code></h2>
<p><code>NetworkStack</code> represents which network stack you want to use for communication. Currently Ceph provides POSIX, RDMA, and DPDK (<code>PosixNetworkStack</code>, <code>RDMANetworkStack</code>, and <code>DPDKNetworkStack</code>, respectively).
<code>PosixNetworkStack</code>, for example, uses POSIX library APIs for network communication (e.g. <code>accept_cloexec()</code>, <code>connect()</code>, <code>sendmsg()</code>, and <code>read()</code>).</p>
<p>NetworkStack spawns multiple worker threads with <code>Worker</code> class instance.
These threads are independent from dispatch thread; <code>Worker</code> threads are responsible to wait any messages from peers and send messages to them.</p>
<p><code>NetworkStack</code> and <code>Worker</code>s are created when <code>AsyncMessenger</code> is created.</p>
<pre><code class="language-cpp">// Clients uses Messenger::create_client_messenger() to call AsyncMessenger::create().
// Servers directly calls AsyncMessenger::create().
AsyncMessenger::create() (new AsyncMessenger() -&gt; NetworkStack::create() -&gt; new PosixNetworkStack() and NetworkStack::create())
-&gt; PosixNetworkStack::start()
-&gt; PosixNetworkStack::spawn_worker()
-&gt; std::thread()
-&gt; (thread) lambda function defined in NetworkStack::add_thread()
</code></pre>
<p><code>src/msg/Messenger.cc</code> and <code>src/msg/async/AsyncMessenger.cc</code></p>
<pre><code class="language-cpp">// in src/msg/Messenger.cc
Messenger *Messenger::create(CephContext *cct, const std::string &amp;type,
			     entity_name_t name, std::string lname, uint64_t nonce) {
  return new AsyncMessenger(cct, name, type, std::move(lname), nonce);
}

// in src/msg/async/AsyncMessenger.cc
AsyncMessenger::AsyncMessenger(CephContext *cct, entity_name_t name,
                               const std::string &amp;type, std::string mname, uint64_t _nonce)
    : SimplePolicyMessenger(cct, name),
      dispatch_queue(cct, this, mname),
      nonce(_nonce) {
  std::string transport_type = &quot;posix&quot;;
  // StackSingletone ensures that there is exactly only one network stack in the process.
  // Return type: StackSingleton&amp;
  auto single = &amp;cct-&gt;lookup_or_create_singleton_object&lt;StackSingleton&gt;(
    &quot;AsyncMessenger::NetworkStack::&quot; + transport_type, true, cct);
  single-&gt;ready();
  stack = single-&gt;stack.get();
  stack-&gt;start();
  ...
}

struct StackSingletone {
  ...
  void ready(std::string &amp;type) {
    if (!stack) stack = NetworkStack::create(cct, type);
  }
};
</code></pre>
<p><code>src/msg/async/Stack.cc</code> and <code>src/msg/async/PosixStack.h</code></p>
<pre><code class="language-cpp">std::shared_ptr&lt;NetworkStack&gt; NetworkStack::create(CephContext *c,
						   const std::string &amp;t) {
  std::shared_ptr&lt;NetworkStack&gt; stack = nullptr;
  if (t == &quot;posix&quot;) stack.reset(new PosixNetworkStack(c));
  ...

  for (unsigned worker_id = 0; worker_id &lt; stack-&gt;num_workers; ++worker_id) {
    Worker *w = stack-&gt;create_worker(c, worker_id);
    ...
  }
  return stack;
}

Worker *PosixNetworkStack::create_worker(CephContext *c, unsigned worker_id) override {
  return new PosixWorker(c, worker_id);
}
</code></pre>
<p><code>src/msg/async/Stack.cc</code> and <code>src/msg/async/PosixStack.h</code></p>
<pre><code class="language-cpp">void NetworkStack::start() {
  ...
  for (unsigned i = 0; i &lt; num_workers; ++i) {
    if (workers[i]-&gt;is_init()) continue;
    std::function&lt;void ()&gt; thread = add_thread(i);
    spawn_worker(i, std::move(thread));
  }
}

void PosixNetworkStack::spawn_worker(unsigned i, std::function&lt;void ()&gt; &amp;&amp;func) override {
  threads.resize(i+1);
  threads[i] = std::thread(func);
}
</code></pre>
<p>Note that <code>func</code> is passed by <code>add_thread()</code> function, which returns a lambda function for thread execution:</p>
<p><code>src/msg/async/Stack.cc</code></p>
<pre><code class="language-cpp">std::function&lt;void()&gt; NetworkStack::add_thread(unsigned worker_id) {
  Worker* w = workers[worker_id];
  return [this, w]() {
    ...
    w-&gt;initialize();
    w-&gt;init_done();
    while (!w-&gt;done) {
      int r = w-&gt;center.process_events(EventMaxWaitUs, &amp;dur);
    }
    w-&gt;reset();
    w-&gt;destroy();
  };
}
</code></pre>
<p>The number of threads to be created depends on Ceph configuration value <code>ms_async_op_threads</code> [^cephmsfconf]. The default value is 3, and you can override it by specifying the number in ceph.conf.
Note that there also exists <code>ms_async_max_op_threads</code> configuration, which is by default 5, that limits the maximum number of threads.</p>
<p>Created threads create their own <code>EventCenter</code> and wait events in parallel, which will be discussed in the next subsection.</p>
<h3 id="socket-subclasses">Socket subclasses</h3>
<p>Socket file descriptors are encapsulated into Ceph&rsquo;s classes (<code>ServerSocket</code> and <code>ConnectedSocket</code>, which have <code>ServerSocketImpl</code> and <code>ConnectedSocketImpl</code> respectively), and for each type of network stack they are inherited:</p>
<ul>
<li><code>PosixNetworkStack</code> -&gt; use <code>PosixServerSocketImpl</code> and <code>PosixConnectedSocketImpl</code></li>
<li><code>RDMANetworkStack</code> -&gt; use <code>RDMAServerSocketImpl</code> and <code>RDMAConnectedSocketImpl</code></li>
<li><code>DPDKNetworkStack</code> -&gt; use <code>DPDKServerSocketImpl</code> and <code>DPDKConnectedSocketImpl</code></li>
</ul>
<p>If <code>OSD</code> binds a server socket:</p>
<pre><code class="language-cpp">main() (ceph-osd.cc)
-&gt; AsyncMessenger::bindv()
-&gt; AsyncMessenger::Processor::bind()
-&gt; PosixWorker::listen() (-&gt; ::bind(), ::listen(), and new PosixServerSocketImpl())
</code></pre>
<p><code>src/msg/async/AsyncMessenger.cc</code> and <code>src/msg/async/PosixStack.cc</code></p>
<pre><code class="language-cpp">int AsyncMessenger::bindv(const entity_addrvec_t &amp;bind_addrs) {
  ...
  for (auto &amp;&amp;p : processors) {
    p-&gt;bind(bind_addrs, avoid_ports, &amp;bound_addrs);
    ...
  }
}

int Processor::bind(const entity_addrvec_t &amp;bind_addrs,
		    const std::set&lt;int&gt;&amp; avoid_ports,
		    entity_addrvec_t* bound_addrs) {
  worker-&gt;center.submit_to(
    worker-&gt;center.get_id(),
    [this, k, &amp;listen_addr, &amp;opts, &amp;r]() {
      r = worker-&gt;listen(listen_addr, k, opts, &amp;listen_sockets[k]);
    },
    false
  );
  ...
}

// in src/msg/async/PosixStack.cc
int PosixWorker::listen(entity_addr_t&amp; sa,
                        unsigned addr_slot,
                        const SocketOptions&amp; opt,
                        ServerSocket* sock) {
  int listen_sd = net.create_socket(sa.get_family(), true);
  net.set_nonblock(listen_sd);
  net.set_socket_options(listen_sd, opt.nodelay, opt.rcbuf_size);

  ::bind(listen_sd, sa.get_sockaddr(), sa.get_sockaddr_len());
  ::listen(listen_sd, cct-&gt;_conf-&gt;ms_tcp_listen_backlog);
  
  *sock = ServerSocket(std::unique_ptr&lt;PosixServerSocketImpl&gt;(
      new PosixServerSocketImpl(net, listen_sd, sa, addr_slot)));
  return 0;
}
</code></pre>
<blockquote>
<p>Note that <code>ServerSocket</code> and <code>ConnectedSocket</code> illustrated in <a href="#connection">connection</a> subsection indicate these classes.</p>
</blockquote>
<p>All I/O communication are passed to and from those socket classes. Will be discussed a little bit more detail below.</p>
<h3 id="sending-messages">Sending messages</h3>
<p>Before going to the next subsection, let&rsquo;s talk about sending messages, since worker threads are for <strong>receiving</strong> ones asynchronously.</p>
<p>Very simply, upper class instances (e.g. <code>OSD</code>) use <code>Connection::send_message()</code> to send a message to the peer.</p>
<p><code>src/osd/OSD.cc</code></p>
<pre><code class="language-cpp">bool OSD::ms_dispatch(Message *m) {
  ...
  _dispatch(m);
}

void OSD::_dispatch(Message *m) {
  switch (m-&gt;get_type()) {
  ...
  case MSG_COMMAND:
    handle_command(static_cast&lt;MCommand*&gt;(m));
    return;
  }
  ...
}

void OSD::handle_command(MCommand *m) {
  ConnectionRef con = m-&gt;get_connection();
  auto session = ceph::ref_cast&lt;Session&gt;(con-&gt;get_priv());
  if (!session) {
    con-&gt;send_message(new MCommandReply(m, -EACCES));
    m-&gt;put;
    return;
  }
  ...
}
</code></pre>
<p>Then, <code>AsyncConnection</code> internally uses <code>ConnectedSocket</code> to send data to the peer:</p>
<pre><code class="language-cpp">AsyncConnection::write()
-&gt; AsyncConnection::_try_send()
-&gt; PosixConnectedSocketImpl::send()
-&gt; PosixConnectedSocketImpl::do_sendmsg()
-&gt; ::sendmsg()
</code></pre>
<p><code>src/msg/async/AsyncConnection.cc</code> and <code>src/msg/async/PosixStack.cc</code></p>
<pre><code class="language-cpp">ssize_t AsyncConnection::write(ceph::buffer::list &amp;bl,
                               std::function&lt;void(ssize_t)&gt; callback,
                               bool more) {
  ...
  outgoing_bl.claim_append(bl);
  ssize_t r = _try_send(more);
  if (r &gt; 0) {
    writeCallback = callback;
  }
  return r;
}

ssize_t AsyncConnection::_try_send(bool more) {
  ...
  // type of variable cs: ConnectedSocket
  cs.send(outgoing_bl, more);
  ...
}

// src/msg/async/PosixStack.cc
ssize_t send(ceph::buffer::list &amp;bl, bool more) override {
  ...
  uint64_t left_pbrs = bl.get_num_buffers();
  while (left_pbrs) {
    ...
    do_sendmsg(_fd, msg, msglen, left_pbrs || more);
    ...
  }
}

#ifndef _WIN32
static ssize_t do_sendmsg(int fd, struct msghdr &amp;msg, unsigned len, bool more) {
  size_t sent = 0;
  while (1) {
    r = ::sendmsg(fd, &amp;msg, MSG_NOSIGNAL | (more ? MSG_MORE : 0));
    sent += r;
    if (len == sent) break;
    ...
  }
  return (ssize_t) sent;
}
</code></pre>
<h2 id="5-eventcenter-and-eventdriver">5. <code>EventCenter</code> and <code>EventDriver</code></h2>
<p><code>EventCenter</code> is responsible to pass events from remote peers to worker threads. A class instance is created and owned by a worker thread mentioned above.
The worker threads use <code>EventCenter</code> to receive events (e.g. connection request from <code>ServerSocket</code>, and message arrive from <code>ConnectedSocket</code>, connection reset, etc).</p>
<h3 id="initialization">Initialization</h3>
<p>At first, when <code>PosixWorker</code> instances are created, each class instance initializes <code>EventCenter</code> as well.</p>
<p><code>src/msg/async/PosixStack.h</code> and <code>src/msg/async/Stack.h</code></p>
<pre><code class="language-cpp">class PosixWorker : public Worker {
  ceph::NetHandle net;
  void initialize() override;
 public:
  PosixWorker(CephContext *c, unsigned i) : Worker(c, i), net(c) {}
  ...
};

class Worker {
  ...
  Worker(CephContext *c, unsigned worker_id)
    : cct(c), perf_logger(NULL), id(worker_id), references(0), center(c) {
    ...
  }
}
</code></pre>
<p>The <code>Worker</code> constructor initializes <code>EventCenter</code> member variable named <code>center</code>.</p>
<p>After creating <code>EventCenter</code> instances, all workers call <code>center.process_events()</code> infinitely to process pending events asynchronously:</p>
<p><code>src/msg/async/Stack.cc</code></p>
<pre><code class="language-cpp">// lambda function defined in NetworkStack::add_thread
// executed by worker threads
[this, w]() {
  ...
  w-&gt;initialize();
  w-&gt;init_done();
  while(!w-&gt;done()) {
    ...
    w-&gt;center.process_events(EventMaxWaitUs, &amp;dur);
    ...
  }
};
</code></pre>
<p><code>EventCenter::process_events()</code> internally uses <code>EventDriver</code> to receive events.</p>
<h3 id="eventdriver">EventDriver</h3>
<p><code>EventDriver</code>, like <code>NetworkStack</code>, is an abstracted class for event control mechanism. In Linux, Ceph uses <code>epoll</code> by default, <code>kqueue</code> for BSD, etc: it provides four types of <code>EventDriver</code>: <code>EpollDriver</code>, <code>SelectDriver</code>, <code>KqueueDriver</code>, and <code>DPDKDriver</code>.</p>
<p><code>src/msg/async/Event.cc</code> and <code>src/msg/async/EventEpoll.cc</code></p>
<pre><code class="language-cpp">int EventCenter::init(int nevent, unsigned center_id, const std::string &amp;type) {
  if (type == &quot;dpdk&quot;) {
#ifdef HAVE_DPDK
    driver = new DPDKDriver(cct);
#endif
  } else {
#ifdef HAVE_EPOLL
  driver = new EpollDriver(cct);
#else
#ifdef HAVE_KQUEUE
  driver = new KqueueDriver(cct);
#else
  driver = new SelectDriver(cct);
#endif
#endif
  }
  ...
}

int EventCenter::process_events(unsigned timeout_microseconds,  ceph::timespan *working_dur) {
  ...
  std::vector&lt;FiredFileEvent&gt; fired_events;
  numevents = driver-&gt;event_wait(fired_events, &amp;tv);
  for (int event_id = 0; event_id &lt; numevents; event_id++) {
    FileEvent *event = _get_file_event(fired_events[event_id].fd);
    cb-&gt;do_request(fired_events[event_id].fd);
  }

  ...
}

int EpollDriver::event_wait(std::vector&lt;FiredFileEvent&gt; &amp;fired_events, struct timeval *tvp) {
  int retval = epoll_wait(epfd, events, nevent,
                          tvp ? (tvp-&gt;tv_sec*1000 + tvp-&gt;tv_usec/1000) : -1);
  ...
  return numevents;
}
</code></pre>
<p>when the worker thread receives an event, it calls the specified callback function <code>cb-&gt;do_request()</code>.
What is it?</p>
<h3 id="event-callback-receiving-messages">Event Callback (receiving messages)</h3>
<p>It is normal to say that we <em><strong>must</strong></em> register a callback function to be called when an event has been arrived.
Ceph provides <code>EventCallback</code> class and asks them to implement a child class of <code>EventCallback</code> and override <code>EventCallback::do_request()</code>, the function that would be called by the worker thread when an event occurs.</p>
<p>For example, <code>AsyncMessenger::Processor</code> has <code>Processor::C_processor_accept</code> class, which is used to accept a connection request in an asynchronous manner:</p>
<p><code>src/msg/async/AsyncMessenger.cc</code></p>
<pre><code class="language-cpp">class Processor::C_processor_accept : public EventCallback {
  Processor *pro;

 public:
  explicit C_processor_accept(Processor *p): pro(p) {}
  void do_request(uint64_t id) override {
    pro-&gt;accept();
  }
};

void Processor::accept() {
  for (auto&amp; listen_socket : listen_sockets) {
    while (true) {
      ConnectedSocket cli_socket;
      listen_socket.accept(&amp;cli_socket, opts, &amp;addr, w);
      msgr-&gt;add_accept(w, std::move(cli_socket),
                       msgr-&gt;get_myaddrs().v[listen_socket.get_addr_slot()],
                       addr);
      ...
    }
  }
}
</code></pre>
<p>When a <code>Processor</code> class instance is created, a <code>Processor::C_processor_accept</code> class instance is created as well, and this is passed with server socket file descriptor to the <code>EventCenter</code> when the processor begins execution.</p>
<p><code>src/msg/async/AsyncMessenger.cc</code></p>
<pre><code class="language-cpp">Processor::Processor(AsyncMessenger *r, Worker *w, CephContext *c)
  : msgr(r), net(c), worker(w),
    listen_handler(new C_processor_accept(this)) {}

void Processor::start() {
  worker-&gt;center.submit_to(
      worker-&gt;center.get_id(),
      [this]() {
        worker-&gt;center.create_file_event(listen_socket.fd(), EVENT_READABLE, listen_handler);
      },
      false
    );
  )
}
</code></pre>
<p><code>EventCenter::create_file_event()</code> uses <code>EventDriver</code> again to register the passed file descriptor to I/O multiplexer (in this post, EPOLL):</p>
<p><code>src/msg/async/Event.cc</code> and <code>src/msg/async/EventEpoll.cc</code></p>
<pre><code class="language-cpp">int EventCenter::create_file_event(int fd, int mask, EventCallbackRef ctxt) {
  ...
  driver-&gt;add_event(fd, event-&gt;mask, mask);
  ...
}

int EpollDriver::add_event(int fd, int cur_mask, int add_mask) {
  ...
  epoll_ctl(epfd, op, fd, &amp;ee);
  ...
}
</code></pre>
<p>As aforementioned, the worker threads are waiting to receive any events from the epoll, and the other threads addds the file descriptor into the epoll and when an event occurs, worker threads would wake up and handle it by calling <code>do_request()</code> callback function.</p>
<p>For instance, accepting a connection request is handled as follows:</p>
<pre><code class="language-cpp">EventCenter::process_events() (-&gt; EventDriver::event_wait() -&gt; epoll_wait())
-&gt; Processor::C_processor_accept::do_request()
-&gt; Processor::accept() (-&gt; PosixServerSocketImpl::accept() -&gt; ::accept_cloexec() and new PosixConnectedSocketImpl())
-&gt; AsyncMessenger::add_accept()
-&gt; ceph::make_ref&lt;AsyncConnection&gt;() // AsyncConnection is created with the accepted socket fd and ConnectedSocket class instance
</code></pre>
<section class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1" role="doc-endnote">
<p><a href="https://sketch2sky.com/2017/12/11/ceph-asyncmessenger%E6%A8%A1%E5%9D%97%E7%AE%80%E6%9E%90/">Ceph ASyncMessenger 简析 I</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2" role="doc-endnote">
<p><a href="http://blog.wjin.org/posts/ceph-async-messenger.html">Ceph Async Messenger</a>&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3" role="doc-endnote">
<p><a href="https://mahatic.com/2018/11/04/ceph-async-messenger/">Ceph ASync Messenger</a>&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:4" role="doc-endnote">
<p><a href="https://www.programmersought.com/article/43365361621/">Ceph async network communication source code analysis 1</a>&#160;<a href="#fnref:4" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:5" role="doc-endnote">
<p><a href="https://www.programmersought.com/article/4493505512/">Ceph AsyncMessenger source analysis (below)</a>&#160;<a href="#fnref:5" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:6" role="doc-endnote">
<p><a href="https://www.programmersought.com/article/48264588038/">Ceph network module - AsyncMessenger data structure analysis</a>&#160;<a href="#fnref:6" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:7" role="doc-endnote">
<p><a href="https://www.programmersought.com/article/93104587967/">Ceph network module - AsyncMessenger code flow analysis</a>&#160;<a href="#fnref:7" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</section>

    </div>
    
    <div class="my-4">
    
    <a href="/tags/study/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka">#study</a>
    
    <a href="/tags/ceph/" class="inline-block bg-tertiary-bg text-sm rounded px-3 py-1 my-1 mr-2 hover:text-eureka">#ceph</a>
    
</div>
    
    
    
    
    
    
    
<div class="flex flex-col md:flex-row md:justify-between -mx-2 mt-4 px-2 pt-4 border-t">
    <div>
        
        <span class="block font-bold">Previous</span>
        <a href="/2021-03-04/using-ceph-rbd-as-a-qemu-storage/" class="block">Using Ceph RBD as a QEMU Storage</a>
        
    </div>
    <div class="md:text-right mt-4 md:mt-0">
        
        <span class="block font-bold">Next</span>
        <a href="/2020-11-09/building-container-image-inside-container-using-buildah/" class="block">Building Container Image inside Container using Buildah</a>
        
    </div>
</div>

    

<div id="disqus_thread"></div>
<script>
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "insujang" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


</div>




<div
    class="col-span-2 lg:col-start-2 lg:col-span-6 bg-secondary-bg rounded p-6">
    <h2 class="text-lg font-semibold mb-4">See Also</h2>
    <div class="content">
        
        <a href="/2020-11-07/accelerating-ceph-rpm-packaging-using-multithreaded-compression/">Accelerating Ceph RPM Packaging: Using Multithreaded Compression</a>
        <br />
        
        <a href="/2020-11-03/deploying-a-ceph-development-environment-cluster/">Deploying a Ceph Development Environment Cluster</a>
        <br />
        
        <a href="/2020-08-30/introduction-to-ceph/">Introduction to Ceph</a>
        <br />
        
        <a href="/2020-11-09/building-container-image-inside-container-using-buildah/">Building Container Image inside Container using Buildah</a>
        <br />
        
        <a href="/2020-08-27/introduction-to-flatpak/">Introduction to Flatpak</a>
        <br />
        
        <a href="/2020-08-24/dynamic-kubelet-configuration/">Dynamic Kubelet Configuration</a>
        <br />
        
    </div>
</div>

</div>
<script>
    document.addEventListener('DOMContentLoaded', ()=>{
        hljs.initHighlightingOnLoad();
    })
</script>

      </div>
    
  </main>
  <footer class="pl-scrollbar">
    <div class="w-full max-w-screen-xl mx-auto"><div class="text-center p-6 pin-b">
    <p class="text-sm text-tertiary-text">&copy; 2017 - 2021 Insu Jang &middot;  Powered by the <a href="https://github.com/wangchucheng/hugo-eureka" class="hover:text-eureka">Eureka</a> theme for <a href="https://gohugo.io" class="hover:text-eureka">Hugo</a></p>
</div></div>
  </footer>
</body>

</html>